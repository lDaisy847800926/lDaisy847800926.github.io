<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git详细使用手册]]></title>
    <url>%2F2018%2F02%2F01%2FGit%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Git 命令大汇总用户信息 git config –global user.name Simon 设置自己的用户名 git config –global user.email jinmaup@gmail.com 设置自己的邮箱 查看配置git config –list 查看自己git的配置信息 设置编辑器git config –global core.editor vim 当你用git编辑文件时，编辑文件的文本编辑器会默认调用vim 文本着色git config –global color.ui true 可为大部分git的代码布上颜色 基础命令建立版本库 git init 当前路径文件 初始化为Git仓库（可以发现 当前路径增加了.git文件夹） git init 文件夹名 新建一个文件夹，并将其初始化为Git代码库 文件添加到暂存区 git add . 把当前目录所有未追踪文件，已修改的文件，添加到暂存区 (不包括被删除的文件) git add 文件（夹）名 把特定文件（夹）添加到暂存区 git add -A 提交所有的文件操作到暂存区 git add -u 提交已修改的文件,被删除的文件（不包括新文件） git add -p 交互式的缓存提交，会提供多个选项来自定义提交内容、方式 文件添加到本地仓库 git commit -m”commit message” 把暂存区的所有文件添加到本地仓库，-m”提交信息” （越详细越好） git commit 文件（夹）名 -m”commit message” 把特定文件（夹）添加到本地仓库，-m”提交信息” （越详细越好） git commit -am”commit message” 针对已经被追踪的文件，可以直接添加到本地仓库，不用先add在commit. git commit –amend -m”commit message” 利用本次commit 重写上一次commit git commit –amend –no-edit 利用本次commit 重写上一次commit 不会重写上次commit的提交信息 仓库状态获取git status 可以立即获取本地仓库状态 以及 git的步骤提示，建议多使用此命令 版本回退 git reset –hard HEAD 将工作区，暂存区，本地仓库恢复到上一个版本（–hard） git reset –soft HEAD^^^ 将本地仓库恢复到上三个版本,不会修改暂存区，工作区（–soft） git reset –mixd HEAD~5 将暂存区，本地仓库恢复到上五个版本，不会修改工作区（–mixd，默认） git reset –hard commitID 将工作区，暂存区，本地仓库恢复到上指定版本其中commitID就是每一次commit的版本号，可以使用git reflog获取 撤销暂存 git reset HEAD file.txt 撤销file.txt的add操作，使其变成不跟踪状态 git reset HEAD^ file.txt 将上一次提交版本的file.txt重新置入缓存区 撤销工作区 git checkout – file.txt （只针对未追踪文件）用历史中的file.txt替换现有工作区的file.txt如果文件增加到暂存区后 又进行了修改，那么执行命令后 将回到暂存区文件状态 git checkout HEAD – file.txt 用最后一次提交版本中的file.txt 替换现有工作区的file.txt git checkout commitID – file.txt 用特定版本的file.txt 替换现有工作区的file.txt 撤销提交git revert commitID 撤销指定版本的commit，并将此操作生成一个全新的commit并提交 文件操作增 touch touch 文件名 ： 新建文件 mkdir mkdir 文件夹名： 新建文件夹 vim vim 文件名 ： 新建文件，并用vim模式打开该文件进行编写 git init git init 文件夹名：新建一个文件夹，并将其初始化为Git代码库 printf printf ‘content’ &gt; 文件名 ：新建一个文件，并把content注入其内容 echo echo ‘content’ &gt; 文件名 ：新建一个文件，并把content注入其内容 删 rm rm 文件名 : 删除文件 clean git clean -f 文件名 ：删除未跟踪文件 改 vim vim 文件名 ： 打开文件，并用vim模式进行修改 mv mv 选定文件名 新的文件名：把选定文件名 修改为 新的文件名 printf printf ‘content’ &gt; 文件名 ： 将 content 替换 文件原有内容 echo echo ‘content’ &gt; 文件名 ： 将 content 替换 文件原有内容 查 pwd 得到当前路径 cd cd 路径 ：进到某一文件路径 cd .. : 回退文件路径 cd : 回到默认的路径 cat cat 文件名：查看该文件的内容 ls 查看该目录下的文件列表（不包括隐藏文件） ls -a 查看该目录下的文件列表（包括隐藏文件） show git show:：展示任意分支某一文件的内容 分支操作查看分支 git branch 列出本地分支 git branch -r 列出远端分支 git branch -a 列出所有分支 git branch -v 查看各个分支最后一个提交对象的信息 git branch –merge 查看已经合并到当前分支的分支 git branch –no-merge 查看为合并到当前分支的分支 git remote show origin 可以查看remote地址，远程分支 新建分支 git branch name 新建一个名为name的分支 git checkout -b name 新建一个名为name的分支，并自动切换为该分支 git branch [branch] [commit] 新建一个分支，指向指定commit git branch –track [branch] [remote-branch] 新建一个分支，与指定的远程分支建立追踪关系 删除分支 git branch -d name 删除一个名为name的分支 git branch -D name 强制删除一个名为name的分支 git push: 删除远程分支 git push origin –delete 删除远程分支 切换分支 git checkout name 切换一个名为name的分支 git checkout - 切换上一个分支 重命名分支git branch -m name将当前所在分支命名为 name 标签新建标签 git tag [tag] 新建一个tag在当前commit git tag [tag] [commit] 新建一个tag在指定commit git tag v0.9 commitID 对某次提交新建标签 查看标签git tag 列出所有tag 删除标签 git tag -d [tag] 删除本地tag git push origin :refs/tags/ 可以删除一个远程标签 推送标签 git push origin –tags 一次性推送全部尚未推送到远程的本地标签 git push origin 可以推送一个本地标签 远程仓库 git remote 显示所关联的远程仓库 git remote -v 显示更详细信息 git remote add origin git@server-name:path/repo-name.git 关联一个远程库 git remote rm name 删除一个远程库 git remote rename 将远程连接从重命名为 合并 git rebase master 将master分之上超前的提交，变基到当前分支 git rebase –interactive 交互模式，修改commit git rebase –continue 处理完冲突继续合并 git rebase –skip 跳过合并 git rebase –abort 取消合并 查看汇总查看信息 git whatchanged –since=’2 weeks ago’ 查看两个星期内的改动 git log –follow [file] 显示某个文件的版本历史 git log –author=”John” 它会显示所有作者叫 John 的提交 get log –after=”yesterday” 查看昨天的历史信息 git log -3 展示最近3次历史信息 git log –graph 可以看到分支合并图 修改历史git rebase -i commitID 将pick 替换成 r , 然后回车，vi退出可以使用 :x 修改 git的历史记录的提交信息 查看文件 git diff HEAD – readme.txt 可以查看工作区和版本库里面最新版本的区别 git diff –staged 显示暂存区（已经add）的文件和版本库文件的比较 git ls-files 查看在暂存区的文件 删除暂存git rm –cached 文件名 把文件从暂缓区 返回至 工作区 其他忽略文件 echo node_modules/ &gt;&gt; .gitignore 添加忽略文件 打包 git archive master –format=zip –output=master.zip 将Master分支打包 git bundle create 将历史记录包括分支内容打包到一个文件中 git clone repo.bundle-b 从某个Bundle中导入工作区 git stash 将工作区现场（已跟踪文件）储藏起来 git stash list 查看保存的工作现场 git stash apply 恢复工作现场 git stash drop 删除stash内容 git stash pop 恢复的同时直接删除stash内容 git stash apply stash@{0} 恢复指定的工作现场 查找内容 git grep “Hello” 从当前目录的所有文件中查找文本内容 git grep “Hello” v2.5 在某一版本中搜索文本 帮助 git help -a]]></content>
      <tags>
        <tag>Git</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云Ubuntu上软件的安装和卸载]]></title>
    <url>%2F2018%2F01%2F30%2F%E9%98%BF%E9%87%8C%E4%BA%91Ubuntu%E4%B8%8A%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[1、Ubuntu相关命令sudo apt-get update 更新源 sudoapt-get install package安装包 sudo apt-get install --reinstall 重新安装包 sudo apt-get remove package 删除 sudo apt-cache search package 搜索软件包 sudo apt-get - -f install 修复安装 2、FTP安装 sudo apt-get install vsftpd 安装ftp 3、WinSCP 上传文件 与虚拟机连接 4、scp 复制文件到阿里云上 scp -r /文件路径/xx.txt root@120.77.252.50：/ root/ 复制阿里云文件到本地上 scp -r root@0.0.0.0：/ root/xx.txt /本地路径 5、阿里云的使用 虚拟机中的 ssh常用于远程连接到阿里云 阿里云的根用户 root 2、新建用户，新添加的用户为daisy useradd -m daisy passwd daisy密码：xxxx usermod -a -G adm daisy usermod -a -G sudo daisy 超级用户 vim /etc/sudoers 写daisy一个一样的 su - daisy 切换到用户daisy下 以下是在阿里云上的安装：3、在阿里云上安装python3.6步骤如下：`sudo apt-get update 更新源 sudo apt-get install software-properties-commn 安装安全协议 sudo add-apt-repository ppa:jonathonf/python-3.6 sudo apt-get update 更新源 sudo apt-get install python3.6 安装python3.6 cd usr/bin 切换 以下操作都在 usr/bin目录下执行： / usr / bin ls | grep python 查看所有的python cd usr/bin 下 sudo rm python 删除软链接 cd usr/bin 下sudo ln -s python3.6m python 创建python3.软链接 sudo apt-get install python3-pip 为python3安装pip pip --version python pip install --upgrade pip 为pip升级 将python3配置为默认的 ` 4、虚拟环境安装：`创建python3.6的虚拟机环境： cd /usr/bin 目录下： sudo pip install virtualenv sudo pip install virtualenvwrapper mkdir ~/.virtualenvs 虚拟环境就在目录下 sudo vim ~/.bashrc 在末尾添加： export WORKON_HOME=$home/.vitualenvs source / usr/ bin/ virtualenvwrapper.sh source ~/.bashrc 激活虚拟环境 deactivate 退出虚拟机环境 ### 创建python3的虚拟机环境 ### mkvirtualenv --python=/usr/bin/python3 djangopy3 ### 创建python2.7的虚拟机环境： ### mkvirtualenv py2 --python=/usr/bin/python2 ` 5、安装mysql`sudo apt-get install mysql-server 安装mysql的服务 用户名 root 密码 root 打开本地的Navicat，连接本地数据库，打开mysql数据库下的mysql,打开 所有的表，点击user ,将localhost修改为% xshell上登录mysql 修改mysql的配置 mysql -u root -p use mysql update user set host=&quot;%&quot; where user=&quot; root&quot;; grant all privileges on *.* to &quot; root&quot; @&quot; %&quot; identifiend by &quot;root&quot; 设置权限 sudo vim /etc/mysql /mysql.conf.d/mysqld.cnf 下 43行 bind-address: 0.0.0.0 sudo service mysql restart 重启mysql服务 mysql服务是自启的` 6、安装MongoDB`sudo tar -zxvf mongodb-linux-x86_64-ubuntu-3.4.0tgz 解压MongoDB sudo mv mongodb /usr/local/mongodb 移动mongodb encho PATH 先查看一下环境变量 sudo vim /etc /profile 最后一行添加 export PATH=/usr/ local/mongodb/bin:$PATH 为MongoDB添加环境变量 source /etc/profile 激活MongoDB sudo vim /etc/mongodb.conf mongodb的配置,直接复制以下 #详细记录输出 verbose = true #指定服务端口号，默认端口27017 port = 27017 #指定MongoDB日志文件，注意是指定文件不是目录 logpath = /home/daisy/mongodb/logs/mongodb.log #使用追加的方式写日志 logappend = true #指定数据库路径 dbpath = /home/daisy/mongodb/db #设置每个数据库将被保存在一个单独的目录 directoryperdb = true #启用验证 auth = false 以守护进程的方式运行MongoDB，创建服务器进程 fork = true #安静输出 quiet = true mkdir /home/daisy/mongodb/logs -p 创建MongoDB的日志目录 mkdir /home/daisy/mongodb/db touch /home/daisy/mongodb/logs/mongodb.log mongod -f /etc/mongod.conf 启动MongoDB服务 手动启动 mongo 启动MongoDB` 注册MongoDB开机自启动：sudo vim /etc/init.d/mongodb 复制以下内容： ` #!/bin/sh ### BEGIN INIT INFO # Provides: mongodb # Required-Start: # Required-Stop: # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: mongodb # Description: mongo db server ### END INIT INFO . /lib/lsb/init-functions PROGRAM=/usr/local/mongodb/bin/mongod MONGOPID=`ps -ef | grep &apos;mongod&apos; | grep -v grep | awk &apos;{print $2}&apos;` test -x $PROGRAM || exit 0 case &quot;$1&quot; in start) ulimit -n 3000 log_begin_msg &quot;Starting MongoDB server&quot; $PROGRAM -f /etc/mongod.conf log_end_msg 0 ;; stop) log_begin_msg &quot;Stopping MongoDB server&quot; if [ ! -z &quot;$MONGOPID&quot; ]; then kill -15 $MONGOPID fi log_end_msg 0 ;; status) ;; *) log_success_msg &quot;Usage: /etc/init.d/mongodb {start|stop|status}&quot; exit 1 esac exit 0 sudo chmod a +x /etc/init.d/mongodb 添加权限 sudo update-rc.d mongodb defaults 增加开机脚本 sudo service mongod start 启动 sudo service mongodb stop 停止` 7、redis的安装`sudo apt-get install tcl sudo tar -xvzf redis-3.2.5.tar.gz 解压redis sudo mv redis-3.2.5 /usr/local/redis cd /usr/local/redis 下操作： 编译安装 sudo make sudo make test 测试 sudo make install 安装 测试 cd /usr/local/redis/src /redis-server redis服务器 cd /usr/local/redis/src /redis-cli redis客户端 创建相关目录 sudo mkdir /etc/redis 创建一个redis目录 sudo mkdir /var/lib/redis 创建redis存储路径 安装服务 sudo sh /usr/local/redis/utils/install_server.sh 测试 redis-server redis-cli 配置文件 sudo vim /etc/redis/6379.conf 62行 bind 0.0.0.0 482行 requirepass xxx(用户名) sudo redis-server /etc/redis/6379.conf `]]></content>
      <tags>
        <tag>阿里云，Ubuntu，linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户管理接口文档模板示例]]></title>
    <url>%2F2018%2F01%2F17%2F%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[用户管理接口概述概述： 所属模块 所属构件包 Controller类 Url路径 系统管理 com.nbcb.crm.galaxy com.nbcb.galaxy.controller.UserController com.nbcb.galsxy.user 接口清单 接口名称 说明 编号 queryUserPage 获取用户列表 1 addUser 添加用户 2 queryUserByOrg 根据机构查询用户 3 updateUser 更新用户 4 selectHisPage 编辑历史查询 5 lockUsers 锁定用户 6 unlockUsers 解锁用户 7 resetPwd 密码重置 8 delUser 删除用户 9 recoveryUser 恢复用户 10 分层及对象模型定义 逻辑分层 控制层controller ↓ 服务层service Dao层 model层 Model或参数对象定义 Page 分页信息 字段id 类型 中文说明 pageIndex int 页索引号（从0开始） pageSize int 页大小 GFUser 用户信息 字段id 类型 中文说明 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 GFUserExplnfo 用户信息拓展信息（继承GFUser） 字段id 类型 中文说明 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 GFPosition 职位信息 字段id 类型 中文说明 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 pageIndex int 页索引号（从0开始） pageSize int 页大小 接口详细设计 查询用户 queryUserPage 输入参数： 字段id 类型 中文说明 是否必填 来源 q GFUserExplnfo 查询参数 否 前端输入 password 是 string 密码 password 是 string 密码 q GFUserExplnfo 查询参数 否 前端输入 password 是 string 密码 password 是 string 密码 q GFUserExplnfo 查询参数 否 前端输入 password 是 string 密码 password 是 string 密码 q GFUserExplnfo 查询参数 否 前端输入 password 是 string 密码 password 是 string 密码 输出参数： 字段id 类型 中文说明 data PageData 用户列表 查询逻辑： - 查询用户 新增 addUser 输入参数： 字段id 类型 中文说明 是否必填 来源 user GFUser 用户 是 前端输入 输出参数： 字段id 类型 中文说明 status boolean 状态 处理逻辑： - 判断用户工号是否存在 - 添加用户 - 增加用户更新历史 - 增加职位信息 根据机构查询用户 queryUserByOrg 输入参数： 字段id 类型 中文说明 是否必填 来源 user GFUser 用户 是 前端输入 输出参数： 字段id 类型 中文说明 status boolean 状态 处理逻辑： 编辑用户 updateUser 输入参数： 字段id 类型 中文说明 是否必填 来源 user GFUser 用户 是 前端输入 输出参数： 字段id 类型 中文说明 status boolean 状态 处理逻辑： 查询用户更新记录 selectHisPage 输入参数： 字段id 类型 中文说明 是否必填 来源 user GFUser 用户 是 前端输入 输出参数： 字段id 类型 中文说明 status boolean 状态 处理逻辑： 锁定用户 lockUsers 输入参数： 字段id 类型 中文说明 是否必填 来源 user GFUser 用户 是 前端输入 输出参数： 字段id 类型 中文说明 status boolean 状态 处理逻辑： 解锁用户 unlockUsers 输入参数： 字段id 类型 中文说明 是否必填 来源 user GFUser 用户 是 前端输入 输出参数： 字段id 类型 中文说明 status boolean 状态 处理逻辑： 删除用户 delUser 输入参数： 字段id 类型 中文说明 是否必填 来源 user GFUser 用户 是 前端输入 输出参数： 字段id 类型 中文说明 status boolean 状态 处理逻辑： - 逻辑删除用户，更新变更记录 - HR同步的不能删除 恢复用户 recoveryUser 输入参数： 字段id 类型 中文说明 是否必填 来源 user GFUser 用户 是 前端输入 输出参数： 字段id 类型 中文说明 status boolean 状态 处理逻辑： - 逻辑删除用户，更新变更记录 密码重置 resetPwd 输入参数： 字段id 类型 中文说明 是否必填 来源 user GFUser 用户 是 前端输入 输出参数： 字段id 类型 中文说明 status boolean 状态 处理逻辑： - 循环重置用户密码，更新变更记录]]></content>
      <tags>
        <tag>接口文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 100道常见面试题]]></title>
    <url>%2F2017%2F08%2F22%2FPython%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Python 100道常见笔试题&amp;答案1.python中的pass语句的作用是什么？ pass语句什么也不做,一般作为占位符或者创建占位程序 2.dict中的items()方法与iteritems()方法的不同 dict.items()返回的是一个完整的列表， dict.iteritems()返回的是一个生成器(迭代器) 3.写出尽可能的str对象的方法，并解释其作用 #方法 #描述 S.capitalize() #返回首字母大写的字符串的副本 S.center(width[,fillchar]) #返回一个长度为max(len(S),width),S居中，两侧fillchar填充 S.count(sub[,start[,end]]) #计算子字符串sub的出现次数，可将搜索范围限制为S[start:end] S.decode([encoding[,error]]) #返回使用给定编码方式的字符串的解码版本，由error指定错误处理方式 S.endswith(suffix[start[,end]]) #检查S是否以suffix结尾，可给定[start:end]来选择匹配的范围 S.expandtabs([tabsize]) #返回字符串的副本，其中tab字符会使用空格进行扩展，可选择tabsize S.find(sun[,start[,end]]) #返回子字符串sub的第一个索引，不存在则为-1,可选择搜索范围 S.index(sub[,start[,end]]) #返回子字符串sub的第一个索引，不存在则引发ValueError异常. S.isalnum() #检查字符串是否由字母或数字字符组成 S.isalpha() #检查字符串是否由字母字符组成 S.isdigit() #检查字符串是否由数字字符组成 S.islower() #检查字符串是否由小写字母组成 S.isspace() #检查字符串是否由空格组成 S.istitle() #检查字符串时候首字母大写 S.isupper() #检查字符串是否由大写字母组成 S.join(sequence) #返回其中sequence的字符串元素由S连接的字符串 S.ljust(width[,fillchar]) #返回S副本左对齐的字符串,长度max(len(S),W),右侧fillchar填充 S.lower() #返回所有字符串都为小写的副本 S.lstrip([char]) #向左移除所有char，默认移除(空格,tab,\n) S.partition(seq) #在字符串中搜索seq并返回 S.replace(old,new[,max]) #将new替换olad,最多可替换max次 S.rfind(sub[,start[,end]]) #返回sub所在的最后一个索引，不存在则为-1,可定搜索范围S[start:end] S.rindex(sub[,start[,end]]) #返回sub所在的最后一个索引，不存在则会引发ValueError异常。 S.rjust(width[,fillchar]) #返回S副本右对齐的字符串,长度max(len(S),W),左侧fillchar填充 S.rpartition(seq) #同Partition,但从右侧开始查找 S.rstip([char]) #向右移除所有char，默认移除(空格,tab,\n) S.rsplit(sep[,maxsplit]) #同split,但是使用maxsplit时是从右往左进行计数 S.split(sep[,maxsplit]) #使用sep做为分割符,可使用maxsplit指定最大切分数 S.zfill(width) #在S的左侧以0填充width个字符 S.upper() #返回S的副本，所有字符大写 S.splitlines([keepends]) #返回S中所有行的列表，可选择是否包括换行符 S.startswith(prefix[,start[,end]]) #检查S是否以prefix开始，可用[start,end]来定义范围 S.strip([chars]) #移除所有字符串中含chars的字符，默认移除(空格，tab,\n) S.swapcase() #返回S的副本，所有大小写交换 S.title() #返回S的副本，所有单词以大写字母开头 S.translate(table[,deletechars]) #返回S的副本，所有字符都使用table进行的转换，可选择删除出现在deletechars中的所有字符 4.生成一个指定长度的斐波那契数列 def fibs(x): result = [0, 1] for index in range(x-2): result.append(result[-2]+result[-1]) return result if __name__==&apos;__main__&apos;: num = input(&apos;Enter one number: &apos;) print fibs(num) 5.说明os ,sys模块不同，并列举常用的模块方法？ os.path.exists(file) 如果file存在于当前目录下，返回True，否则返回False os.path.abspath(file) 返回file的绝对路径 os.path.dirname(file) 返回file的上级目录名 sys.path.append(path) 添加path到环境变量 6.什么是lambda函数？它有什么好处？ 当程序代码很短，且该函数只使用一次，为了程序的简洁，及节省变量内存占用空间，引入了匿名函数 函数使用: 1. 代码块重复，这时候必须考虑到函数，降低程序的冗余度 2. 代码块复杂，这时候必须考虑到函数，降低程序的复杂度 7.输入三个整数x ,y ,z ，请把这三个数由小到大输出 def sort_int(a, b, c): L = [a, b, c] L.sort() return L x, y, z = sort_int(100, 10, 1) print(x, y, z) 8.python实现冒泡排序 def bubble_sort(lists): # 冒泡排序 count = len(lists) for i in range(0, count): for j in range(i + 1, count): if lists[i] &gt; lists[j]: lists[i], lists[j] = lists[j], lists[i] return lists 9.有两个升序排列的list A 和B ，尽可能高效的方法将这个两个list合并为一个新的升序排列的list C C=A+B C.sort() 10.有一个list，其中的元素无重复，先由大到小而后由小到大，求出其中的最小元素，要求时间复杂度低于O（n） 11.请将十进制整数10240转换成十六进制整数 a=10240 hex(a)---&gt;0x2800 12.给定一个长为N的，值为整数的数组int_array(如果不方便使用数组，可以用链表代替)写一段程序，在O（n）时间内找出int_array中的第二大的整数。可以使用任意程序设计语言实现。说明：如果最大的整数在int_array中出现了不止一次，则最大的整数和第二大的整数相等。样例数据一：输入：[1,2,3,4,5]输出：4样例数据二：输入:[5,5,4,4,3]输出：5 13.编写个shell脚本将/SBIDATA目录下大于10K的文件转移到/SBIBAEODI目录下，按照备份的日期保存（请使用shell编写） bin/bash programm: name=&apos;date + %y%m%d&apos; do mv $filename /SBIBAEODI done ls -la /SBIBAEODI 14.写一个算法，将字符串列表[“aycc”,”kh”,”llc”,”u”,”l”]通关算法处理为[“y”,’k’,’c’,’u’,’l’],对调字符列表中的字符位置（’y’与’l’对调，’k’与’u’对调），并拼接字符列表中的字符，输出字符串，‘LUCKY’（python编写） 15.请写出一段python代码实现删除一个list里面的重复元素 &gt;&gt;&gt; L1 = [4,1,3,2,3,5,1] &gt;&gt;&gt; L2 = [] &gt;&gt;&gt; [L2.append(i) for i in L1 if i not in L2] &gt;&gt;&gt; print L2 [4, 1, 3, 2, 5] 16.请实现一个实现打印当前时间的装饰器 17.请简述跨域问题，以及服务器针对跨域请求需要做什么处理 18.python是如何进行内存管理的 python内部使用引用计数，来保持追踪内存中的对象，Python内部记录了对象有多少个引用，即引用计数， 当对象被创建时就创建了一个引用计数，当对象不再需要时，这个对象的引用计数为0时，它被垃圾回收。 所有这些都是自动完成，不需要像C一样，人工干预，从而提高了程序员的效率和程序的健壮性。 19.python里面如何实现tuple和list的转换 #From list to Tuple tuple(a_list) #From Tuple to List def to_list(t): return [i if not isinstance(i,tuple) else to_list(i) for i in t] 20.介绍一下except的用法和作用？ ry/except: 捕捉由PYTHON自身或写程序过程中引发的异常并恢复 except: 捕捉所有其他异常 except name: 只捕捉特定的异常 except name, value: 捕捉异常及格外的数据(实例) except (name1,name2) 捕捉列出来的异常 except (name1,name2),value: 捕捉任何列出的异常，并取得额外数据 else: 如果没有引发异常就运行 finally: 总是会运行此处代码 21.介绍一下python下range()函数的用法？ &gt;&gt;&gt; range(10) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &gt;&gt;&gt; range(1, 10) [1, 2, 3, 4, 5, 6, 7, 8, 9] &gt;&gt;&gt; range(0, 9, 2) [0, 2, 4, 6, 8] &gt;&gt;&gt; range(99,0,-10) [99, 89, 79, 69, 59, 49, 39, 29, 19, 9] 相区别的是xrange(),每次只取出一个迭代对象，如果是数据量比较大时，效率较高 22.如何用python来进行查询和替换一个文本字符串？ 可以使用sub()方法来进行查询和替换，sub方法的格式为：sub(replacement, string[, count=0]) replacement是被替换成的文本 string是需要被替换的文本 count是一个可选参数，指最大被替换的数量 23.python里面的match() 和search()的区别？ match()函数只检测RE是不是在string的开始位置匹配，search()会扫描整个string查找匹配, 也就是说match()只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回none 24.运用python匹配HTML tag的时候，&lt;.&gt;和&lt;.?&gt;有什么区别？？ 前者是贪婪匹配，会从头到尾匹配 &lt;a&gt;xyz&lt;/a&gt;， 而后者是非贪婪匹配，只匹配到第一个 &gt;。 25.python里面如何生成随机数？ import random random.random() 它会返回一个随机的0和1之间的浮点数 26.有没有一个工具可以帮助查找python的bug和进行静代码分析？ pycheck： PyChecker是一个python代码的静态分析工具，它可以帮助查找python代码的bug, 会对代码的复杂度和格式提出警告 pylint ： Pylint是另外一个工具可以进行codingstandard检查 27.如何在一个function里面设置一个全局的变量？ global 28.单引号，双引号，三引号的区别 单引号和双引号都可以用来表示一个字符串 三引号的用来表示字符串内容 29.请自己实现一个copy函数（不能调用python的copy函数） 30.一行代码实现对列表a中的偶数位置的元素进行加3后求和 sums = sum(map(lambda x: x + 3, a[1::2])) 31.随机生成100个数（0&lt;n&lt;=100），如何计算得出每个数字的重复次数。输入int a [100]={1,12,53,…..} 32.什么是GIL？ 线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制, 说白了就是一个核只能在同一时间运行一个线程. 对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。 解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能). 33.list=[-2，1，3，-6]如何实现以绝对值大小从小到大将list中内容排序 sorted(list1,key = abs) 34.简述python的is和==的区别 is是对比地址 ==是对比值 35.简述read，readline和Readlines的区别 read 读取整个文件 readline 读取下一行,使用生成器方法 readlines 读取整个文件到一个迭代器以供我们遍历 36.说明创建字典的至少2种方法 1、直接创建 dict = {&apos;name&apos;:&apos;earth&apos;, &apos;port&apos;:&apos;80&apos;} 2、工厂方法 items=[(&apos;name&apos;,&apos;earth&apos;),(&apos;port&apos;,&apos;80&apos;)] dict2=dict(items) dict1=dict(([&apos;name&apos;,&apos;earth&apos;],[&apos;port&apos;,&apos;80&apos;])) 3、fromkeys()方法 dict1={}.fromkeys((&apos;x&apos;,&apos;y&apos;),-1) dict={&apos;x&apos;:-1,&apos;y&apos;:-1} dict2={}.fromkeys((&apos;x&apos;,&apos;y&apos;)) dict2={&apos;x&apos;:None, &apos;y&apos;:None} 37.args ,*kwargs的作用是什么？如何使用？ 当你不确定你的函数里将要传递多少参数时你可以用*args. 例如,它可以传递任意数量的参数: &gt;&gt;&gt; def print_everything(*args): for count, thing in enumerate(args): print &apos;{0}. {1}&apos;.format(count, thing) &gt;&gt;&gt; print_everything(&apos;apple&apos;, &apos;banana&apos;, &apos;cabbage&apos;) 0. apple 1. banana 2. cabbage 相似的,**kwargs允许你使用没有事先定义的参数名: &gt;&gt;&gt; def table_things(**kwargs): for name, value in kwargs.items(): print &apos;{0} = {1}&apos;.format(name, value) &gt;&gt;&gt; table_things(apple = &apos;fruit&apos;, cabbage = &apos;vegetable&apos;) cabbage = vegetable apple = fruit *args和**kwargs可以同时在函数的定义中,但是*args必须在**kwargs前面. 38.python中的变量作用域（变量查找顺序） Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。 当 Python 遇到一个变量的话他会按照这样的顺序进行搜索： 本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in） 39.数组和元组之间的区别是什么？ 列表可以修改，而元组不可以修改 如果元组中仅有一个元素，则要在元素后加上逗号。 元组只可读不可修改。 如果程序中的数据不允许修改可用元组。 40.python都有哪些自带的数据结构？ 列表，元组，字符串，bytes，bytearray，集合，字典 41.xrange 和range的区别是什么？ xrange的用法与range完全相同，所不同的是xrange生成的不是一个list，而是一个生成器。 要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间。 range会直接生成一个list对象： &gt;&gt;&gt; a = range(0, 50) &gt;&gt;&gt; print type(a) &lt;type &apos;list&apos;&gt; &gt;&gt;&gt; print a [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49] 而xrange则不会直接生成一个list，而是每次调用返回其中的一个值： &gt;&gt;&gt; a = xrange(0, 50) &gt;&gt;&gt; print type(a) &lt;type &apos;xrange&apos;&gt; &gt;&gt;&gt; print a xrange(50） 42.如何在python中拷贝一个对象？ 标准库中的copy模块提供了两个方法来实现拷贝. 一个方法是copy,它返回和参数包含内容一样的对象. 一个方法是使用deepcopy方法,对象中的属性也被复制 43.简述python的优缺点？ 优点： 简单，易学，免费、开源，可移植性，解释性，面向对象，可扩展性，丰富的库 缺点： 运行速度慢 44.写一个程序，用递归的方法计算n! def fact(n): if n==1: return 1 return n * fact(n - 1) 45.TCP/IP协议中各协议所在层以及他们之间的关系 46.有序列表如[1,3,5,7,9]，请用二分查找返回元素所在的位置 47.用列表生成器1到100的偶数列表，并且a[50:100]返回什么？ 48.将字符串倒叙，如a=’abcdefg’变成’gfedcba’ reverse 49.用最少行数计算某字符串（有只有数据和空格）中偶数的和，a=’12 21 23 22 5 67’ 50.一般怎么优化响应慢的接口？ 51.针对接口设计，有哪些安全设计？ 52.简述爬虫的基本工作原理，目前主要的网站结构以及设计对各类结构网站的爬取方法 网络爬虫的基本工作流程如下： 1.首先选取一部分精心挑选的种子URL； 2.将这些URL放入待抓取URL队列； 3.从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。 4.分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环 53.请画出scrapy爬虫结构图，并对其进行解释 Scrapy Engine： 负责组件之间数据的流转，当某个动作发生时触发事件 Scheduler： 接收requests，并把他们入队，以便后续的调度 Downloader： 负责抓取网页，并传送给引擎，之后抓取结果将传给spider Spiders： 用户编写的可定制化的部分，负责解析response，产生items和URL Item Pipeline： 负责处理item，典型的用途：清洗、验证、持久化 Downloader middlewares： 位于引擎和下载器之间的一个钩子，处理传送到下载器的requests和传送到引擎的response(若需要在Requests到达Downloader之前或者是responses到达spiders之前做一些预处理，可以使用该中间件来完成) Spider middlewares： 位于引擎和抓取器之间的一个钩子，处理抓取器的输入和输出 (在spiders产生的Items到达Item Pipeline之前做一些预处理或response到达spider之前做一些处理) 54，什么是爬取深度？什么是广度优先策略，什么是深度优先策略？scrapy如何控制爬取深度（在哪里设置，其核心的控制代码在哪里） 深度优先遍历策略是指网络爬虫会从起始页开始，一个链接一个链接跟踪下去，处理完这条线路之后再转入下一个起始页，继续跟踪链接 宽度优先遍历策略的基本思路是，将新下载网页中发现的链接直接插入待抓取URL队列的末尾。也就是指网络爬虫会先抓取起始网页中链接的所有网页，然后再选择其中的一个链接网页，继续抓取在此网页中链接的所有网页 55.scrapy中爬取列表的去重机制是什么？在代码中如何实现？ 1、Pipleline 加入如下代码：（在数据爬完后将URL塞入redis去重） class RedisInsert(object): def process_item(self,item,spider): set_redis_values_1(item[&apos;url&apos;]) return item 2、Middleware加入如下代码：（在爬数据之前查看该URL是否爬取过） class IngoreRequestMiddleware(object): def __init__(self): self.middlewareLogging=getLogger(&quot;IngoreRequestMiddleware&quot;) def process_request(self,request,spider): if get_redis_values_1(request.url): self.middlewareLogging.debug(&quot;IgnoreRequest : %s&quot; % request.url) raise IgnoreRequest(&quot;IgnoreRequest : %s&quot; % request.url) else: self.middlewareLogging.debug(&quot;haveRequest : %s&quot; % request.url) return None 56.是否使用过redis，简述redis中有哪些数据结构，并说明基本用途（至少3种） String——字符串 Hash——字典 List——列表 Set——集合 Sorted Set——有序集合 57.爬虫程序对于服务器的要求主要在哪些方面？ 58.在web服务中，想要显示只允许某一个ip访问，应该怎么实现？ 59.写程序把一个单向链表顺序倒过来。（尽可能写出更多的实现方法，标出所写方法的空间和时间复杂度） 60.有一个长度为n的数组a,里面元素都是整数，现有一个整数B，写程序判断数组a中是否有两个元素的和等于B。（尽可能写出更多的实现方法，标出所写方法的空间和时间复杂度） 61.什么是缓存，在web服务中，缓存有什么作用，什么情况下要使用缓存，缓存分为几种？ web缓存的类型： 1、浏览器缓存 2、代理服务器缓存 3、网关缓存 62.什么是负载均衡，负载均衡有什么作用，有哪些负载均衡算法？ 负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 负载均衡算法： 1.轮询法 2.随机法 3.源地址哈希法 4.加权轮询法 5.加权随机法 6.最小连接数法 63.简述对RESTful API设计规范的理解 64.简述HTTP缓存机制 65.如何实现一个可供with的语句使用的上下文管理对象 文件可以作为上下文管理器使用，它们可以关闭自身作为清理的一部分 &gt;&gt;&gt; with open(&apos;text.txt&apos;) as myfile: ... while True: ... line = myfile.readline() ... if not line: ... break ... print line, 66.简述python内置实现的一些设计模式 答：解释器模式，适配器模式，桥接模式， 67.简述python垃圾回收机制及如何解决循环引用 Python的GC模块主要运用了引用计数来跟踪和回收垃圾。 在引用计数的基础上，还可以通过“标记－清除”解决容器对象可能产生的循环引用的问题。 通过分代回收以空间换取时间进一步提高垃圾回收的效率 68.简述什么样的情况下会发生UnicodeDecodeError 安装模块时候发生编码错误 69.异常捕捉中except分支中raise e 改为 raise 会产生哪些变化？ raise抛出一个异常 70.给出3个你经常访问的技术网站或博客 GitHub、Stack OverFlow、CSND，oschina，博客园、SegmentFault 71.简述标准库中，functools.wraps的作用 functools.wraps 的作用是将原函数对象的指定属性复制给包装函数对象, 默认有 module、name、doc,或者通过参数选择 72.简述标准库中，functools.partial的实现思路 functools 中Partial可以用来改变一个方法默认参数 1.改变原有默认值参数的默认值 2.给原来没有默认值的参数增加默认值 73.写出一段代码实现单例模式 使用new方法 class Singleton(object): def __new__(cls, *args, **kw): if not hasattr(cls, &apos;_instance&apos;): orig = super(Singleton, cls) cls._instance = orig.__new__(cls, *args, **kw) return cls._instance class MyClass(Singleton): a = 1 74.用yield写出一个生成器 def cube(n): for i in range(n): yield i ** 3 for i in cube(5): print i 75.@classmethod ,@staticmethod ,@property都是什么意思? classmethod(fn)表明函数fn是类的函数而非类实例的函数 staticmethod(fn)表明函数fn是类的静态方法 @property可以实现属性的只读权限功能 76.解释一下Gevent和threading/multiprocessing的关系 77.请解释一下cookie和session的关系，以及xsrf的攻击和防范方法 session技术是要使用到cookie的，之所以出现session技术，主要是为了安全 78.函数、类方法定义中如何实现可选参数、可选关键字参数 79.解释classmethod和staticmethod的区别 @staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样 @classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数 80.写一段程序，包含迭代器和生成器的使用 81.如何使用匿名函数 当程序代码很短，且该函数只使用一次，为了程序的简洁，及节省变量内存占用空间，引入了匿名函数 &gt;&gt;&gt; nums = range(2,20) &gt;&gt;&gt; for i in nums: nums = filter(lambda x:x==i or x % i,nums) &gt;&gt;&gt; nums [2, 3, 5, 7, 11, 13, 17, 19] 82.如何使用标准库collections中的deque? deque 是 double-ended queue的缩写，类似于 list，不过提供了在两端插入和删除的操作。 1.appendleft 在列表左侧插入 2.popleft 弹出列表左侧的值 3.extendleft 在左侧扩展 83.标准库中的copy中的copy和deepcopy的区别 copy：浅拷贝。只拷贝父对象，不会拷贝对象的内部的子对象 deepcopy：深拷贝。拷贝对象及其子对象 84.什么是装饰器，如何使用装饰器？ 装饰器本质上是一个Python函数，它可以让其它函数在不作任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。 85.解释with关键字的用法 with 的一般执行过程 一段基本的with表达式，其结构是这样的： with EXPR as VAR: BLOCK 其中：EXPR可以是任意表达式；as VAR是可选的。其一般的执行过程是这样的： 计算EXPR，并获取一个上下文管理器。 上下文管理器的__exit()__方法被保存起来用于之后的调用。 调用上下文管理器的__enter()__方法。 如果with表达式包含as VAR，那么EXPR的返回值被赋值给VAR。 执行BLOCK中的表达式。 调用上下文管理器的__exit()__方法。如果BLOCK的执行过程中发生了一个异常导致程序退出，那么异常的type、value和traceback(即sys.exc_info()的返回值)将作为参数传递给__exit()__方法。否则，将传递三个None。 86.参数传递使用的是传递引用还是传递值？为什么？ 值传递：方法调用时，实际参数把它的值传递给对应的形式参数，方法执行中形式参数值的改变不影响实际参数的值。 87.在类的方法定义中，‘self’是怎样的一个参数 self代表当前对象的地址。 self能避免非限定调用造成的全局变量。 88.进程和线程的区别是什么？ 线程是操作系统中能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。 一个线程指的是进程中一个单一顺序的控制流。 一个进程中可以并发多条线程，每条线程并行执行不同的任务 进程就是一个程序在一个数据集上的一次动态执行过程。 进程有以下三部分组成： 1，程序：我们编写的程序用来描述进程要完成哪些功能以及如何完成。 2，数据集：数据集则是程序在执行过程中需要的资源，比如图片、音视频、文件等。 3，进程控制块：进程控制块是用来记录进程的外部特征，描述进程的执行变化过程，系统可以用它来控制和管理进程，它是系统感知进程存在的唯一标记。 区别： 1、运行方式不同 进程不能单独执行，它只是资源的集合。 进程要操作CPU，必须要先创建一个线程。 所有在同一个进程里的线程，是同享同一块进程所占的内存空间。 2、关系 进程中第一个线程是主线程，主线程可以创建其他线程；其他线程也可以创建线程；线程之间是平等的。 进程有父进程和子进程，独立的内存空间，唯一的标识符：pid 3、速度 启动线程比启动进程快。 运行线程和运行进程速度上是一样的，没有可比性。 线程共享内存空间，进程的内存是独立的。 89.对list进行切片的用法 a = list[::10] 切片操作符： [],[:],[::] 90.用两种方式按行读取一个csv文件 1.使用python的csv模块 csv.reader(filepath) 2.使用python的pandas库 pandas.read_csv(file) 91.简述数据库的锁机制 92.mysql有几种存储引擎，特点是什么？ 存储引擎：MyISAM,InnoDB,MEMORY,MERGE 93.写一个函数，能够遍历一个文件夹下的所有文件和子文件夹 def getfilelist(filepath, tabnum=1): simplepath = os.path.split(filepath)[1] returnstr = simplepath+&quot;目录&lt;&gt;&quot;+&quot;\n&quot; returndirstr = &quot;&quot; returnfilestr = &quot;&quot; filelist = os.listdir(filepath) for num in range(len(filelist)): filename=filelist[num] if os.path.isdir(filepath+&quot;/&quot;+filename): returndirstr += &quot;\t&quot;*tabnum+getfilelist(filepath+&quot;/&quot;+filename, tabnum+1) else: returnfilestr += &quot;\t&quot;*tabnum+filename+&quot;\n&quot; returnstr += returnfilestr+returndirstr return returnstr+&quot;\t&quot;*tabnum+&quot;&lt;/&gt;\n&quot; path = raw_input(&quot;请输入文件路径:&quot;) usefulpath = path.replace(&apos;\\&apos;, &apos;/&apos;) if usefulpath.endswith(&quot;/&quot;): usefulpath = usefulpath[:-1] if not os.path.exists(usefulpath): print &quot;路径错误!&quot; elif not os.path.isdir(usefulpath): print &quot;输入的不是目录!&quot; else: filelist = os.listdir(usefulpath) o=open(&quot;test.xml&quot;,&quot;w+&quot;) o.writelines(getfilelist(usefulpath)) o.close() print &quot;成功！请查看test.xml文件 94.python多线程与多进程的区别 多线程可以共享全局变量，多进程不能。 多线程中，所有子线程的进程号相同； 多进程中，不同的子进程进程号不同 1.多线程: 语法 join 线程锁之Lock\Rlock\信号量 将线程变为守护进程 Event事件 queue队列 生产者消费者模型 2.多进程: 语法 join 进程Queue 进程Pipe 进程Manager 进程同步 进程池 95.python是如何进行类型转换的？ 函数 描述 int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 96.如何用python来发送邮件 python实现发送和接收邮件功能主要用到poplib和smtplib模块。 poplib用于接收邮件，而smtplib负责发送邮件。 97.python中单下划线和双下划线是什么意思？ __foo__:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突， _foo:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问； 98.urllib和urllib2的区别 urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。 urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等 99.get和post区别 get用于获取数据 post 用于修改数据 100.python网络爬虫所用到的网络数据包和解析数据包有哪些？ 网络数据包： requests、urllib、urllib2、httplib2 解析数据包： BeautifulSoup、pyquery、Xpath、lxml]]></content>
      <tags>
        <tag>Python</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教小白用 hexo + Github 搭建属于自己的博客（下）]]></title>
    <url>%2F2017%2F07%2F22%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%B0%8F%E7%99%BD%E7%94%A8-hexo-Github-%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[主题的配置：这里以believe主题作为题材(也就是我现在所使用的主题)主题选择： https://hexo.io/themeshexo官网上有许多的好看炫酷的主题，可以从中选择一个自己心仪的 最经典的主题是next，网上对于next主题的配置也非常多，所以可以从网上找到配置next主题的教程，但是在这里我还是主要以我的这个主题来配置 http://www.tianhao.site/blog 这是我选择的主题的原本样子 https://ldaisy847800926.github.io/ 这是我自己使用这个主题后的样子 在这里就不详细讲解我这个主题的配置了 https://github.com/th720309/hexo-theme-believe 这个主题所有的配置，都可以在这里看到，按照博主的步骤来即可，不管你选择哪一个主题，都需要安装博主的GitHub上详细的步骤来安装和使用哦 感谢believe博主提供的相信这个主题٩(๑❛ᴗ❛๑)۶ 我会好好的对待我的博客的٩(๑&gt;◡&lt;๑)۶ 有任何疑问都可以帮忙解答哦，欢迎一起学习（ゝω・）]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教小白用 hexo + Github 搭建属于自己的博客 （中）]]></title>
    <url>%2F2017%2F07%2F22%2F%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[安装Hexo在自己认为合适的地方创建一个文件夹，这里我以G：/hexo 为例子讲解，首先在G盘目录下创建Hexo文件夹，并在命令行的窗口进入到该目录在命令行中输入： `npm install hexo-cli -g` 安装需要一些时间，然后你将会看到一个WAN,不用管，这不会印象你的正常使用，然后输入： `npm install hexo --save` 来看一看Hexo是不是已经安装好了。 在命令行中输入： ` hexo -v` 如果你看到了如图文字，则说明已经安装成功了 hexo的相关配置初始化Hexo 接着上面的操作，输入： `hexo init` 然后输入： `npm install` 之后npm将会自动安装你需要的组件，只需要等待npm操作即可。 首次体验Hexo继续操作，同样是在命令行中，输入： `hexo g` 然后输入： `hexo s` 然后会提示： 在浏览器中打开http://localhost:4000/，你将会看到： 到目前为止，Hexo在本地的配置已经全都结束了。 怎样将Hexo与github page 联系起来大概分为以下: 配置git个人信息 配置Deployment 配置Git个人信息1、设置Git的user name和email：(如果是第一次的话) `git config --global user.name &quot;lDaisy847800926&quot;` git config --global user.email &quot;daisy847800926@163.com&quot;2、生成密钥 输入cd ~/.ssh，检查是否由.ssh的文件夹 ssh-keygen -t rsa -C &quot;daisy847800926@163.com&quot; 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 配置Deployment同样在_config.yml文件中(初始化后hexo中的文件)，找到Deployment，repo值是你在github项目里的ssh（右下角）然后按照如下修改： deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 比如我的仓库的地址是git@github.com:lDaisy847800926/lDaisy847800926.github.io.git，所以配置如下 deploy: type: git repo: git@github.com:lDaisy847800926/lDaisy847800926.github.io.git branch: master 写博客、发布文章新建一篇博客，执行下面的命令： `hexo new post &quot;article title&quot;` 这时候在我的 电脑的目录下 G:\hexo\source\ _posts 将会看到 article title.md 文件 需要提前安装一个扩展： `npm install hexo-deployer-git --save` 然后用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令： ` hexo g // 生成` `hexo d // 部署` 当然你也可以执行下面的命令，相当于上面两条命令的效果 `hexo d -g #在部署前先生成` hexo 安装和配置完成]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教小白用 hexo + Github 搭建属于自己的博客 （上）]]></title>
    <url>%2F2017%2F07%2F22%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%B0%8F%E7%99%BD%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[大概可以分为以下几个步骤 搭建环境准备（包括node.js和git环境，gitHub账户的配置） 安装Hexo 、配置Hexo 怎样将Hexo与github page 联系起来、怎样发布文章 主题 推荐 和 主题配置 搭建环境准备大概可以分为以下三步 Node.js 的安装和准备 git的安装和准备 gitHub账户的配置 配置Node.js环境 下载Node.js安装文件： https://nodejs.org/en/ node.js官网下载 根据自己的Windows版本来选择相应的安装文件，例如我选择的是64-bit 保持默认设置即可，一路Next，安装很快就结束了。 然后我们检查一下是不是要求的组件都安装好了，同时按下Win和R，打开运行窗口，在新打开的窗口中输入cmd，敲击回车，打开命令行界面。在打开的命令行界面中，输入 `node -v` `nmp -v` 如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。 Git的安装和准备下载Git安装文件： https://git-scm.com/downloads git官网下载 根据自己的Windows版本选择git版本，我选择的是64-bit 安装时一直next，默认设置即可 检查一个Git是否安装正确，打开命令行，输入： `git --version ` 结果如图所示，则说明安装成功，可以进行下一步了，如果不正确，回头检查自己的安装过程 github账户的注册和配置如果已经拥有账号，请跳过此步 第一步: Github注册 打开 https://github.com/， 在下图的框中，分别输入自己的用户名，邮箱，密码。 然后前往自己刚才填写的邮箱，点开Github发送给你的注册确认信，确认注册，结束注册流程。 一定要确认注册，否则无法使用gh-pages！ 第二步: 创建代码库登陆之后，点击页面右上角的加号，选择New repository： 新建代码库进入代码库创建页面： 在Repository name下填写yourname.github.io，Description (optional)下填写一些简单的描述（不写也没有关系），如图所示： 注意：比如我的github名称是ldaisy847800926 ,这里你就填 ldaisy847800926.github.io,如果你的名字是xujun，那你就填 xujun.github.io 第三步: . 代码库设置正确创建之后，你将会看到如下界面： 接下来开启gh-pages功能，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages，如图：Github pages 在GitHub page设置时候，会选择一个GitHub page的主题，随便选择自己想要的主题即可。 点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。 参考的教程链接：http://blog.csdn.net/gdutxiaoxu/article/details/53576018 https://www.cnblogs.com/fengxiongZz/p/7707219.html http://www.cnblogs.com/fengxiongZz/p/7707568.html]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
